// *********************************************************
//
// File autogenerated for the skin_client_real package
// by the rosparam_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <ros/param.h>
#include <control_core/ros/parameters.h>
#include <rosparam_handler/utilities_std.h>
#include <control_core/types.h>
#ifdef DYNAMIC_RECONFIGURE_FOUND
#include <skin_client_real/SkinClientRealConfig.h>
#include <dynamic_reconfigure/server.h>
namespace skin_client_real
{
    typedef dynamic_reconfigure::Server<SkinClientRealConfig> SkinClientRealServer;
}
#else
namespace skin_client_real
{
    struct SkinClientRealConfig{};
    struct SkinClientRealServer{};
}
#endif


namespace skin_client_real {

/// \brief Parameter struct generated by rosparam_handler
class SkinClientRealParameters : public cc::Parameters {

public:
  typedef cc::Parameters Base;
  using Config = SkinClientRealConfig;

public:
  SkinClientRealParameters()
  : Base(), config_updated_once_(false)
  {
    addToList();
  }

  SkinClientRealParameters(const ros::NodeHandle& private_node_handle, const std::string& private_namespace="")
  : Base(private_node_handle, private_namespace), config_updated_once_(false) 
  {
    addToList();
  }

  ~SkinClientRealParameters() { }

  /// \brief Get values from parameter server
  /// 
  /// Will fail if a value can not be found and no default value is given.
  bool fromParamServer() {
    bool success = true;
    success &= utilities_std::getParam(private_namespace_ + "maximum_distance", maximum_distance);
    success &= utilities_std::getParam(private_namespace_ + "f_transf_exp", f_transf_exp);
    success &= utilities_std::getParam(private_namespace_ + "f_transf_offset", f_transf_offset);
    success &= utilities_std::getParam(private_namespace_ + "dead_cell_dist_thres", dead_cell_dist_thres);
    success &= utilities_std::getParam(private_namespace_ + "dead_cell_force_thes", dead_cell_force_thes);
    success &= utilities_std::getParam(private_namespace_ + "max_num_of_masked_cells", max_num_of_masked_cells);
    success &= utilities_std::getParam(private_namespace_ + "force_gain", force_gain);
    success &= utilities_std::getParam(private_namespace_ + "proximity_gain", proximity_gain);
    success &= utilities_std::getParam(private_namespace_ + "scale_by_active", scale_by_active);
    success &= utilities_std::getParam(private_namespace_ + "force_thres", force_thres);
    success &= utilities_std::getParam(private_namespace_ + "proximity_thres", proximity_thres);

    if(!success){
      missingParamsWarning();
      ROS_ERROR("RosparamHandler: GetParam could not retrieve parameter.");
    }
    ROS_DEBUG_STREAM(*this);
    is_loaded_ = true;
    return success;
  }

  /// \brief Get values from parameter server
  /// 
  /// Will fail if a value can not be found and no default value is given.
  bool fromParamServer(const ros::NodeHandle& private_node_handle, const std::string& private_namespace="") {
    private_namespace_ = rosparam_handler::joinNamespaces({private_node_handle.getNamespace(), private_namespace});
    node_name_ = rosparam_handler::getNodeName(private_node_handle);
    is_init_ = true;
    return fromParamServer();
  }

  /// \brief Set parameters on ROS parameter server.
  bool toParamServer() {
  utilities_std::setParam(private_namespace_ + "maximum_distance",maximum_distance);
  utilities_std::setParam(private_namespace_ + "f_transf_exp",f_transf_exp);
  utilities_std::setParam(private_namespace_ + "f_transf_offset",f_transf_offset);
  utilities_std::setParam(private_namespace_ + "dead_cell_dist_thres",dead_cell_dist_thres);
  utilities_std::setParam(private_namespace_ + "dead_cell_force_thes",dead_cell_force_thes);
  utilities_std::setParam(private_namespace_ + "max_num_of_masked_cells",max_num_of_masked_cells);
  utilities_std::setParam(private_namespace_ + "force_gain",force_gain);
  utilities_std::setParam(private_namespace_ + "proximity_gain",proximity_gain);
  utilities_std::setParam(private_namespace_ + "scale_by_active",scale_by_active);
  utilities_std::setParam(private_namespace_ + "force_thres",force_thres);
  utilities_std::setParam(private_namespace_ + "proximity_thres",proximity_thres);
    return true;        
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void fromConfig(const Config& config, const uint32_t level = 0) {
#ifdef DYNAMIC_RECONFIGURE_FOUND

#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  void toConfig(Config& config) {
#ifdef DYNAMIC_RECONFIGURE_FOUND
    
#else
      ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So toConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  Config asConfig() const {
    Config config;
#ifdef DYNAMIC_RECONFIGURE_FOUND
    
#else
      ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So toConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
    return config;
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void updateConfig(Config& config, const uint32_t level = 0) {
#ifdef DYNAMIC_RECONFIGURE_FOUND
  if(!config_updated_once_)
  {
    // first update, override config
    config_updated_once_ = true;
    toConfig(config);
  }
  else
  {
    // subsequent update, read from config
    fromConfig(config, level);
  }
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So updateConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  /// \brief Stream operator for printing parameter struct
  friend std::ostream& operator<<(std::ostream& os, const SkinClientRealParameters& p)
  {
    os << "[" << p.node_name_ << "]\nNode " << p.node_name_ << " has the following parameters:\n"
      << "	" << p.private_namespace_ << "maximum_distance:" << p.maximum_distance << "\n"
      << "	" << p.private_namespace_ << "f_transf_exp:" << p.f_transf_exp << "\n"
      << "	" << p.private_namespace_ << "f_transf_offset:" << p.f_transf_offset << "\n"
      << "	" << p.private_namespace_ << "dead_cell_dist_thres:" << p.dead_cell_dist_thres << "\n"
      << "	" << p.private_namespace_ << "dead_cell_force_thes:" << p.dead_cell_force_thes << "\n"
      << "	" << p.private_namespace_ << "max_num_of_masked_cells:" << p.max_num_of_masked_cells << "\n"
      << "	" << p.private_namespace_ << "force_gain:" << p.force_gain << "\n"
      << "	" << p.private_namespace_ << "proximity_gain:" << p.proximity_gain << "\n"
      << "	" << p.private_namespace_ << "scale_by_active:" << p.scale_by_active << "\n"
      << "	" << p.private_namespace_ << "force_thres:" << p.force_thres << "\n"
      << "	" << p.private_namespace_ << "proximity_thres:" << p.proximity_thres << "\n"
;
    return os;
  }

public:
    double maximum_distance; /*!<  */
  double f_transf_exp; /*!<  */
  double f_transf_offset; /*!<  */
  double dead_cell_dist_thres; /*!<  */
  double dead_cell_force_thes; /*!<  */
  int max_num_of_masked_cells; /*!<  */
  double force_gain; /*!<  */
  double proximity_gain; /*!<  */
  bool scale_by_active; /*!<  */
  double force_thres; /*!<  */
  double proximity_thres; /*!<  */

private:
  bool config_updated_once_;
  /// \brief Add them to the parmeter list
  void addToList() {
        Base::addReference("maximum_distance", maximum_distance);
    Base::addReference("f_transf_exp", f_transf_exp);
    Base::addReference("f_transf_offset", f_transf_offset);
    Base::addReference("dead_cell_dist_thres", dead_cell_dist_thres);
    Base::addReference("dead_cell_force_thes", dead_cell_force_thes);
    Base::addReference("max_num_of_masked_cells", max_num_of_masked_cells);
    Base::addReference("force_gain", force_gain);
    Base::addReference("proximity_gain", proximity_gain);
    Base::addReference("scale_by_active", scale_by_active);
    Base::addReference("force_thres", force_thres);
    Base::addReference("proximity_thres", proximity_thres);
  }

  /// \brief Issue a warning about missing default parameters.
  void missingParamsWarning(){
    ROS_WARN_STREAM("[" << node_name_ << "]\nThe following parameters do not have default values and need to be specified:\n"
      << "	" << private_namespace_ << "maximum_distance" << " (double) \n"
      << "	" << private_namespace_ << "f_transf_exp" << " (double) \n"
      << "	" << private_namespace_ << "f_transf_offset" << " (double) \n"
      << "	" << private_namespace_ << "dead_cell_dist_thres" << " (double) \n"
      << "	" << private_namespace_ << "dead_cell_force_thes" << " (double) \n"
      << "	" << private_namespace_ << "max_num_of_masked_cells" << " (int) \n"
      << "	" << private_namespace_ << "force_gain" << " (double) \n"
      << "	" << private_namespace_ << "proximity_gain" << " (double) \n"
      << "	" << private_namespace_ << "scale_by_active" << " (bool) \n"
      << "	" << private_namespace_ << "force_thres" << " (double) \n"
      << "	" << private_namespace_ << "proximity_thres" << " (double) \n"
    );
  }
};

} // namespace skin_client_real
