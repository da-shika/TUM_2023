// *********************************************************
//
// File autogenerated for the ics_tsid_tasks package
// by the rosparam_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <ros/param.h>
#include <control_core/ros/parameters.h>
#include <rosparam_handler/utilities_std.h>
#include <control_core/types.h>
#include <rosparam_handler/utilities_eigen.h>
#ifdef DYNAMIC_RECONFIGURE_FOUND
#include <ics_tsid_tasks/TaskSkinForceConstraintsConfig.h>
#include <dynamic_reconfigure/server.h>
namespace ics_tsid_tasks
{
    typedef dynamic_reconfigure::Server<TaskSkinForceConstraintsConfig> TaskSkinForceConstraintsServer;
}
#else
namespace ics_tsid_tasks
{
    struct TaskSkinForceConstraintsConfig{};
    struct TaskSkinForceConstraintsServer{};
}
#endif


namespace ics_tsid_tasks {

/// \brief Parameter struct generated by rosparam_handler
class TaskSkinForceConstraintsParameters : public cc::Parameters {

public:
  typedef cc::Parameters Base;
  using Config = TaskSkinForceConstraintsConfig;

public:
  TaskSkinForceConstraintsParameters()
  : Base(), config_updated_once_(false)
  {
    addToList();
  }

  TaskSkinForceConstraintsParameters(const ros::NodeHandle& private_node_handle, const std::string& private_namespace="")
  : Base(private_node_handle, private_namespace), config_updated_once_(false) 
  {
    addToList();
  }

  ~TaskSkinForceConstraintsParameters() { }

  /// \brief Get values from parameter server
  /// 
  /// Will fail if a value can not be found and no default value is given.
  bool fromParamServer() {
    bool success = true;
    success &= utilities_std::getParam(private_namespace_ + "masked_patches", masked_patches, std::vector<std::string>{""});
    success &= utilities_std::getParam(private_namespace_ + "mass", mass);
    success &= utilities_std::getParam(private_namespace_ + "gain", gain);
    success &= utilities_std::getParam(private_namespace_ + "damp", damp);
    success &= utilities_std::getParam(private_namespace_ + "f_max", f_max);
    success &= utilities_std::getParam(private_namespace_ + "f_min", f_min);
    success &= utilities_std::getParam(private_namespace_ + "a_max", a_max);
    success &= utilities_std::getParam(private_namespace_ + "alpha", alpha);
    success &= utilities_eigen::getParam(private_namespace_ + "kp", kp);
    utilities_std::testMin(private_namespace_ + "mass", mass, 0.0);
    utilities_std::testMax(private_namespace_ + "mass", mass, 1.0);
    utilities_std::testMin(private_namespace_ + "gain", gain, 0.0);
    utilities_std::testMax(private_namespace_ + "gain", gain, 5.0);
    utilities_std::testMin(private_namespace_ + "damp", damp, 0.0);
    utilities_std::testMax(private_namespace_ + "damp", damp, 100.0);
    utilities_std::testMin(private_namespace_ + "f_max", f_max, 0.0);
    utilities_std::testMax(private_namespace_ + "f_max", f_max, 5.0);
    utilities_std::testMin(private_namespace_ + "f_min", f_min, 0.0);
    utilities_std::testMax(private_namespace_ + "f_min", f_min, 5.0);
    utilities_std::testMin(private_namespace_ + "a_max", a_max, 0.0);
    utilities_std::testMax(private_namespace_ + "a_max", a_max, 10.0);
    utilities_std::testMin(private_namespace_ + "alpha", alpha, 0.0);
    utilities_std::testMax(private_namespace_ + "alpha", alpha, 0.999);
    utilities_eigen::testMin(private_namespace_ + "kp", kp, 0.0);
    utilities_eigen::testMax(private_namespace_ + "kp", kp, 1000);
    if(!success){
      missingParamsWarning();
      ROS_ERROR("RosparamHandler: GetParam could not retrieve parameter.");
    }
    ROS_DEBUG_STREAM(*this);
    is_loaded_ = true;
    return success;
  }

  /// \brief Get values from parameter server
  /// 
  /// Will fail if a value can not be found and no default value is given.
  bool fromParamServer(const ros::NodeHandle& private_node_handle, const std::string& private_namespace="") {
    private_namespace_ = rosparam_handler::joinNamespaces({private_node_handle.getNamespace(), private_namespace});
    node_name_ = rosparam_handler::getNodeName(private_node_handle);
    is_init_ = true;
    return fromParamServer();
  }

  /// \brief Set parameters on ROS parameter server.
  bool toParamServer() {
  utilities_std::setParam(private_namespace_ + "masked_patches",masked_patches);
  utilities_std::setParam(private_namespace_ + "mass",mass);
  utilities_std::setParam(private_namespace_ + "gain",gain);
  utilities_std::setParam(private_namespace_ + "damp",damp);
  utilities_std::setParam(private_namespace_ + "f_max",f_max);
  utilities_std::setParam(private_namespace_ + "f_min",f_min);
  utilities_std::setParam(private_namespace_ + "a_max",a_max);
  utilities_std::setParam(private_namespace_ + "alpha",alpha);
  utilities_eigen::setParam(private_namespace_ + "kp",kp);
    return true;        
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void fromConfig(const Config& config, const uint32_t level = 0) {
#ifdef DYNAMIC_RECONFIGURE_FOUND
    mass = config.mass;
    gain = config.gain;
    damp = config.damp;
    f_max = config.f_max;
    f_min = config.f_min;
    a_max = config.a_max;
    alpha = config.alpha;
    utilities_eigen::from_string(config.kp_str, kp);
    utilities_eigen::testMin(private_namespace_ + "kp", kp, 0.0);
    utilities_eigen::testMax(private_namespace_ + "kp", kp, 1000);
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  void toConfig(Config& config) {
#ifdef DYNAMIC_RECONFIGURE_FOUND
       config.mass = mass;
   config.gain = gain;
   config.damp = damp;
   config.f_max = f_max;
   config.f_min = f_min;
   config.a_max = a_max;
   config.alpha = alpha;
   config.kp_str = utilities_eigen::to_string(kp);
#else
      ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So toConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  Config asConfig() const {
    Config config;
#ifdef DYNAMIC_RECONFIGURE_FOUND
       config.mass = mass;
   config.gain = gain;
   config.damp = damp;
   config.f_max = f_max;
   config.f_min = f_min;
   config.a_max = a_max;
   config.alpha = alpha;
   config.kp_str = utilities_eigen::to_string(kp);
#else
      ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So toConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
    return config;
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void updateConfig(Config& config, const uint32_t level = 0) {
#ifdef DYNAMIC_RECONFIGURE_FOUND
  if(!config_updated_once_)
  {
    // first update, override config
    config_updated_once_ = true;
    toConfig(config);
  }
  else
  {
    // subsequent update, read from config
    fromConfig(config, level);
  }
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So updateConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  /// \brief Stream operator for printing parameter struct
  friend std::ostream& operator<<(std::ostream& os, const TaskSkinForceConstraintsParameters& p)
  {
    os << "[" << p.node_name_ << "]\nNode " << p.node_name_ << " has the following parameters:\n"
      << "	" << p.private_namespace_ << "masked_patches:" << utilities_std::to_string(p.masked_patches) << "\n"
      << "	" << p.private_namespace_ << "mass:" << p.mass << "\n"
      << "	" << p.private_namespace_ << "gain:" << p.gain << "\n"
      << "	" << p.private_namespace_ << "damp:" << p.damp << "\n"
      << "	" << p.private_namespace_ << "f_max:" << p.f_max << "\n"
      << "	" << p.private_namespace_ << "f_min:" << p.f_min << "\n"
      << "	" << p.private_namespace_ << "a_max:" << p.a_max << "\n"
      << "	" << p.private_namespace_ << "alpha:" << p.alpha << "\n"
      << "	" << p.private_namespace_ << "kp:" << utilities_eigen::to_string(p.kp) << "\n"
;
    return os;
  }

public:
    std::vector<std::string> masked_patches; /*!<  */
  double mass; /*!<  */
  double gain; /*!<  */
  double damp; /*!<  */
  double f_max; /*!<  */
  double f_min; /*!<  */
  double a_max; /*!<  */
  double alpha; /*!<  */
  cc::VectorX kp; /*!<  */

private:
  bool config_updated_once_;
  /// \brief Add them to the parmeter list
  void addToList() {
        Base::addReference("masked_patches", masked_patches);
    Base::addReference("mass", mass);
    Base::addReference("gain", gain);
    Base::addReference("damp", damp);
    Base::addReference("f_max", f_max);
    Base::addReference("f_min", f_min);
    Base::addReference("a_max", a_max);
    Base::addReference("alpha", alpha);
    Base::addReference("kp", kp);
  }

  /// \brief Issue a warning about missing default parameters.
  void missingParamsWarning(){
    ROS_WARN_STREAM("[" << node_name_ << "]\nThe following parameters do not have default values and need to be specified:\n"
      << "	" << private_namespace_ << "mass" << " (double) \n"
      << "	" << private_namespace_ << "gain" << " (double) \n"
      << "	" << private_namespace_ << "damp" << " (double) \n"
      << "	" << private_namespace_ << "f_max" << " (double) \n"
      << "	" << private_namespace_ << "f_min" << " (double) \n"
      << "	" << private_namespace_ << "a_max" << " (double) \n"
      << "	" << private_namespace_ << "alpha" << " (double) \n"
      << "	" << private_namespace_ << "kp" << " (cc::VectorX) \n"
    );
  }
};

} // namespace ics_tsid_tasks
