// *********************************************************
//
// File autogenerated for the joy_target package
// by the rosparam_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <ros/param.h>
#include <control_core/ros/parameters.h>
#include <rosparam_handler/utilities_std.h>
#include <control_core/types.h>
#include <rosparam_handler/utilities_eigen.h>
#ifdef DYNAMIC_RECONFIGURE_FOUND
#include <joy_target/JoyTargetConfig.h>
#include <dynamic_reconfigure/server.h>
namespace joy_target
{
    typedef dynamic_reconfigure::Server<JoyTargetConfig> JoyTargetServer;
}
#else
namespace joy_target
{
    struct JoyTargetConfig{};
    struct JoyTargetServer{};
}
#endif


namespace joy_target {

/// \brief Parameter struct generated by rosparam_handler
class JoyTargetParameters : public cc::Parameters {

public:
  typedef cc::Parameters Base;
  using Config = JoyTargetConfig;

public:
  JoyTargetParameters()
  : Base(), config_updated_once_(false)
  {
    addToList();
  }

  JoyTargetParameters(const ros::NodeHandle& private_node_handle, const std::string& private_namespace="")
  : Base(private_node_handle, private_namespace), config_updated_once_(false) 
  {
    addToList();
  }

  ~JoyTargetParameters() { }

  /// \brief Get values from parameter server
  /// 
  /// Will fail if a value can not be found and no default value is given.
  bool fromParamServer() {
    bool success = true;
    success &= utilities_std::getParam(private_namespace_ + "joy_topic", joy_topic);
    success &= utilities_std::getParam(private_namespace_ + "topic", topic);
    success &= utilities_std::getParam(private_namespace_ + "target_frame", target_frame, std::string{""});
    success &= utilities_eigen::getParam(private_namespace_ + "target_pose", target_pose, std::vector<double>{0,0,0,0,0,0,1});
    success &= utilities_std::getParam(private_namespace_ + "parent_frame", parent_frame);
    success &= utilities_eigen::getParam(private_namespace_ + "mass", mass);
    success &= utilities_eigen::getParam(private_namespace_ + "spring", spring);
    success &= utilities_eigen::getParam(private_namespace_ + "damping", damping);
    success &= utilities_eigen::getParam(private_namespace_ + "acc_lb", acc_lb, std::vector<double>{-100,-100,-100,-100,-100,-100,-100});
    success &= utilities_eigen::getParam(private_namespace_ + "acc_ub", acc_ub, std::vector<double>{100,100,100,100,100,100,100});
    success &= utilities_eigen::getParam(private_namespace_ + "vel_lb", vel_lb, std::vector<double>{-100,-100,-100,-100,-100,-100,-100});
    success &= utilities_eigen::getParam(private_namespace_ + "vel_ub", vel_ub, std::vector<double>{100,100,100,100,100,100,100});
    success &= utilities_eigen::getParam(private_namespace_ + "pos_lb", pos_lb, std::vector<double>{-100,-100,-100});
    success &= utilities_eigen::getParam(private_namespace_ + "pos_ub", pos_ub, std::vector<double>{100,100,100});

    if(!success){
      missingParamsWarning();
      ROS_ERROR("RosparamHandler: GetParam could not retrieve parameter.");
    }
    ROS_DEBUG_STREAM(*this);
    is_loaded_ = true;
    return success;
  }

  /// \brief Get values from parameter server
  /// 
  /// Will fail if a value can not be found and no default value is given.
  bool fromParamServer(const ros::NodeHandle& private_node_handle, const std::string& private_namespace="") {
    private_namespace_ = rosparam_handler::joinNamespaces({private_node_handle.getNamespace(), private_namespace});
    node_name_ = rosparam_handler::getNodeName(private_node_handle);
    is_init_ = true;
    return fromParamServer();
  }

  /// \brief Set parameters on ROS parameter server.
  bool toParamServer() {
  utilities_std::setParam(private_namespace_ + "joy_topic",joy_topic);
  utilities_std::setParam(private_namespace_ + "topic",topic);
  utilities_std::setParam(private_namespace_ + "target_frame",target_frame);
  utilities_eigen::setParam(private_namespace_ + "target_pose",target_pose);
  utilities_std::setParam(private_namespace_ + "parent_frame",parent_frame);
  utilities_eigen::setParam(private_namespace_ + "mass",mass);
  utilities_eigen::setParam(private_namespace_ + "spring",spring);
  utilities_eigen::setParam(private_namespace_ + "damping",damping);
  utilities_eigen::setParam(private_namespace_ + "acc_lb",acc_lb);
  utilities_eigen::setParam(private_namespace_ + "acc_ub",acc_ub);
  utilities_eigen::setParam(private_namespace_ + "vel_lb",vel_lb);
  utilities_eigen::setParam(private_namespace_ + "vel_ub",vel_ub);
  utilities_eigen::setParam(private_namespace_ + "pos_lb",pos_lb);
  utilities_eigen::setParam(private_namespace_ + "pos_ub",pos_ub);
    return true;        
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void fromConfig(const Config& config, const uint32_t level = 0) {
#ifdef DYNAMIC_RECONFIGURE_FOUND

#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  void toConfig(Config& config) {
#ifdef DYNAMIC_RECONFIGURE_FOUND
    
#else
      ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So toConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  Config asConfig() const {
    Config config;
#ifdef DYNAMIC_RECONFIGURE_FOUND
    
#else
      ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So toConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
    return config;
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void updateConfig(Config& config, const uint32_t level = 0) {
#ifdef DYNAMIC_RECONFIGURE_FOUND
  if(!config_updated_once_)
  {
    // first update, override config
    config_updated_once_ = true;
    toConfig(config);
  }
  else
  {
    // subsequent update, read from config
    fromConfig(config, level);
  }
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So updateConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  /// \brief Stream operator for printing parameter struct
  friend std::ostream& operator<<(std::ostream& os, const JoyTargetParameters& p)
  {
    os << "[" << p.node_name_ << "]\nNode " << p.node_name_ << " has the following parameters:\n"
      << "	" << p.private_namespace_ << "joy_topic:" << p.joy_topic << "\n"
      << "	" << p.private_namespace_ << "topic:" << p.topic << "\n"
      << "	" << p.private_namespace_ << "target_frame:" << p.target_frame << "\n"
      << "	" << p.private_namespace_ << "target_pose:" << utilities_eigen::to_string(p.target_pose) << "\n"
      << "	" << p.private_namespace_ << "parent_frame:" << p.parent_frame << "\n"
      << "	" << p.private_namespace_ << "mass:" << utilities_eigen::to_string(p.mass) << "\n"
      << "	" << p.private_namespace_ << "spring:" << utilities_eigen::to_string(p.spring) << "\n"
      << "	" << p.private_namespace_ << "damping:" << utilities_eigen::to_string(p.damping) << "\n"
      << "	" << p.private_namespace_ << "acc_lb:" << utilities_eigen::to_string(p.acc_lb) << "\n"
      << "	" << p.private_namespace_ << "acc_ub:" << utilities_eigen::to_string(p.acc_ub) << "\n"
      << "	" << p.private_namespace_ << "vel_lb:" << utilities_eigen::to_string(p.vel_lb) << "\n"
      << "	" << p.private_namespace_ << "vel_ub:" << utilities_eigen::to_string(p.vel_ub) << "\n"
      << "	" << p.private_namespace_ << "pos_lb:" << utilities_eigen::to_string(p.pos_lb) << "\n"
      << "	" << p.private_namespace_ << "pos_ub:" << utilities_eigen::to_string(p.pos_ub) << "\n"
;
    return os;
  }

public:
    std::string joy_topic; /*!<  */
  std::string topic; /*!<  */
  std::string target_frame; /*!<  */
  cc::CartesianPosition target_pose; /*!<  */
  std::string parent_frame; /*!<  */
  cc::Vector6 mass; /*!<  */
  cc::Vector6 spring; /*!<  */
  cc::Vector6 damping; /*!<  */
  cc::Vector6 acc_lb; /*!<  */
  cc::Vector6 acc_ub; /*!<  */
  cc::Vector6 vel_lb; /*!<  */
  cc::Vector6 vel_ub; /*!<  */
  cc::LinearPosition pos_lb; /*!<  */
  cc::LinearPosition pos_ub; /*!<  */

private:
  bool config_updated_once_;
  /// \brief Add them to the parmeter list
  void addToList() {
        Base::addReference("joy_topic", joy_topic);
    Base::addReference("topic", topic);
    Base::addReference("target_frame", target_frame);
    Base::addReference("target_pose", target_pose);
    Base::addReference("parent_frame", parent_frame);
    Base::addReference("mass", mass);
    Base::addReference("spring", spring);
    Base::addReference("damping", damping);
    Base::addReference("acc_lb", acc_lb);
    Base::addReference("acc_ub", acc_ub);
    Base::addReference("vel_lb", vel_lb);
    Base::addReference("vel_ub", vel_ub);
    Base::addReference("pos_lb", pos_lb);
    Base::addReference("pos_ub", pos_ub);
  }

  /// \brief Issue a warning about missing default parameters.
  void missingParamsWarning(){
    ROS_WARN_STREAM("[" << node_name_ << "]\nThe following parameters do not have default values and need to be specified:\n"
      << "	" << private_namespace_ << "joy_topic" << " (std::string) \n"
      << "	" << private_namespace_ << "topic" << " (std::string) \n"
      << "	" << private_namespace_ << "parent_frame" << " (std::string) \n"
      << "	" << private_namespace_ << "mass" << " (cc::Vector6) \n"
      << "	" << private_namespace_ << "spring" << " (cc::Vector6) \n"
      << "	" << private_namespace_ << "damping" << " (cc::Vector6) \n"
    );
  }
};

} // namespace joy_target
